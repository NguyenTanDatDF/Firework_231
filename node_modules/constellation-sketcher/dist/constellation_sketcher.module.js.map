{"version":3,"sources":["webpack://LIB/webpack/bootstrap","webpack://LIB/./src/constellation_sketcher_utils.js","webpack://LIB/./src/constellation_sketcher.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","randomChoice","array","Math","floor","random","length","extractLinesAtPoint","lines","x","y","extractedLines","filter","line","x1","y1","push","x2","y2","state","nextConstellation","animated","drawLines","twinkle","twinkleTimescale","twinkleAmplitude","speedScale","sizeScale","slideshow","slideshowDwellTime","fadeIn","crossFade","fadeInTime","crossFadeTime","weights","popular","striking","medium","small","drawBeginCallback","drawFrameCompleteCallback","drawCompleteCallback","drawState","oldDrawState","fadeState","recentConstellations","canvasScale","slideshowTimeout","frameRequest","defaults","assign","setConstellation","constellation","this","chooseRandomConstellation","category","constellationCategories","weight","max","forEach","itemWeightsMapping","sumOfWeights","item","choice","randomWeightedChoice","JSON","parse","stringify","getConstellation","getNextConstellation","setAnimated","setDrawLines","setTwinkle","window","requestAnimationFrame","sketchIsEnded","setTwinkleAmplitude","setTwinkleTimescale","setSpeedScale","setSizeScale","setCrossFade","doCrossFade","undefined","setFadeIn","doFadeIn","setSlideshowDwellTime","dwellTime","setSelectionWeightsAll","setSelectionWeightPopular","setSelectionWeightStriking","setSelectionWeightMedium","setSelectionWeightSmall","setDrawBeginCallback","ctx","setDrawFrameCompleteCallback","redrew","setDrawCompleteCallback","sketch","setup","startSketch","startSlideshow","stop","cancelAnimationFrame","clearTimeout","reset","canvas","document","getElementById","getContext","width","height","padding","shift","linesToDraw","linesDrawing","linesFinished","stars","twinkleDeltaMags","fraction","aniStart","aniDuration","twinkleTimestamp","performance","now","Function","v","cdat","constellationData","sx","sy","data","Vmag","start","startLine","startLines","startAnimatingALine","redrawField","onSketchEnd","timestamp","fadeIsStarting","createElement","accumulatedOpacity","buffer","bufferCtx","mainCtx","mainDrawState","twinkleIsTimedOut","clearRect","drawLineFrame","targetOpac","opac","globalAlpha","drawImage","setTimeout","lengths","map","sqrt","pow","oldFraction","newFraction","dx","dy","drawLine","newLinesDrawing","dt","fillStyle","fillRect","idx","mag","beginPath","arc","PI","fill","drawStar","strokeStyle","lineWidth","moveTo","lineTo","stroke","constellationNames","keys"],"mappings":"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","file":"constellation_sketcher.module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","function randomChoice(array) {\n    return array[Math.floor(Math.random() * array.length)];\n}\n\n/**\n * Accepts an object where the keys are items and the values are weights.\n * Returns one randomly-selected item.\n */\nfunction randomWeightedChoice(itemWeightsMapping) {\n    let sumOfWeights = 0;\n    for (const item in itemWeightsMapping)\n        sumOfWeights += itemWeightsMapping[item];\n    \n    let choice = Math.random() * sumOfWeights;\n    for (const item in itemWeightsMapping) {\n        if (itemWeightsMapping[item] >= choice) {\n            return item;\n        }\n        choice -= itemWeightsMapping[item];\n    }\n}\n\n/**\n * Given a set of lines (start and end points), returns all lines which start\n * or end at a given coordinate.\n */\nfunction extractLinesAtPoint(lines, x, y) {\n    const extractedLines = []\n    lines = lines.filter((line) => {\n        if (line.x1 === x && line.y1 === y){\n            extractedLines.push(line)\n            return false;\n        } else if (line.x2 === x && line.y2 === y) {\n            line = {x1: line.x2, y1: line.y2, x2: line.x1, y2: line.y1};\n            extractedLines.push(line)\n            return false;\n        }\n        return true;\n    });\n    return [extractedLines, lines];\n}\n\nexport {randomChoice, randomWeightedChoice, extractLinesAtPoint}","import constellationCategories from \"./constellation_categories.json\";\nimport constellationData from \"./constellation_data.json\";\nimport {randomChoice, randomWeightedChoice, extractLinesAtPoint} from './constellation_sketcher_utils.js';\n\nconst state = {\n    // Configurable values\n    nextConstellation: \"Orion\",\n    animated: true,\n    drawLines: true,\n    twinkle: true,\n    twinkleTimescale: 70,\n    twinkleAmplitude: 1,\n    speedScale: 1,\n    sizeScale: 1,\n    slideshow: false,\n    slideshowDwellTime: 4000,\n    fadeIn: false,\n    crossFade: true,\n    fadeInTime: 750,\n    crossFadeTime: 750,\n    weights: {popular: 2, striking: 2, medium: 1, small: 0},\n    \n    // User-provided callbacks\n    drawBeginCallback: null,\n    drawFrameCompleteCallback: null,\n    drawCompleteCallback: null,\n    \n    // Internal state\n    mode: \"uninitialized\",\n    drawState: null,\n    oldDrawState: null,\n    fadeState: null,\n    recentConstellations: [],\n    canvasScale: null,\n    slideshowTimeout: null,\n    frameRequest: null,\n};\n\n// Store a copy of the default config\nconst defaults = Object.assign({}, state);\n// Ensure `weights` is an independent copy\ndefaults.weights = JSON.parse(JSON.stringify(state.weights));\n\n\n\n/**\n * Functions for configuring state\n*/\n\n\n\nexport function setConstellation(constellation) {\n    state.nextConstellation = constellation;\n    return this;\n}\n\nexport function chooseRandomConstellation() {\n    const weights = {};\n    for (const category in constellationCategories) {\n        const weight = state.weights[category];\n        for (const constellation of constellationCategories[category])\n            weights[constellation] = Math.max(\n                weights[constellation] || 0, weight);\n    }\n    \n    // Don't repeat recent constellations\n    state.recentConstellations.forEach(\n        (constellation) => weights[constellation] = 0);\n    \n    state.nextConstellation = randomWeightedChoice(weights);\n    return this;\n}\n\nexport const getConstellation = () =>\n    state.drawState === null ? null : state.drawState.constellation;\n\nexport const getNextConstellation = () => state.nextConstellation;\n\nexport function setAnimated(animated) {\n    state.animated = animated;\n    return this;\n}\n\nexport function setDrawLines(drawLines) {\n    state.drawLines = drawLines;\n    return this;\n}\n\nexport function setTwinkle(twinkle) {\n    // If twinkle is enabled after a constellation is drawn, start twinkling\n    if (twinkle && !state.twinkle && state.mode === \"waiting\")\n        state.frameRequest = window.requestAnimationFrame(sketchIsEnded);\n    state.twinkle = twinkle;\n    return this;\n}\n\nexport function setTwinkleAmplitude(twinkleAmplitude) {\n    state.twinkleAmplitude = twinkleAmplitude;\n    return this;\n}\n\nexport function setTwinkleTimescale(twinkleTimescale) {\n    state.twinkleTimescale = twinkleTimescale;\n    return this;\n}\n\nexport function setSpeedScale(speedScale) {\n    state.speedScale = speedScale;\n    return this;\n}\n\nexport function setSizeScale(sizeScale) {\n    state.sizeScale = sizeScale;\n    return this;\n}\n\nexport function setCrossFade(doCrossFade, crossFadeTime) {\n    if (doCrossFade !== undefined)\n        state.crossFade = doCrossFade;\n    if (crossFadeTime !== undefined)\n        state.crossFadeTime = crossFadeTime;\n    return this;\n}\n\nexport function setFadeIn(doFadeIn, fadeInTime) {\n    if (doFadeIn !== undefined)\n        state.fadeIn = doFadeIn;\n    if (fadeInTime !== undefined)\n        state.fadeInTime = fadeInTime;\n    return this;\n}\n\nexport function setSlideshowDwellTime(dwellTime) {\n    state.slideshowDwellTime = dwellTime;\n    return this;\n}\n\nexport function setSelectionWeightsAll(weight) {\n    for (let key in state.weights)\n        state.weights[key] = weight;\n    return this;\n}\n\nexport function setSelectionWeightPopular(weight) {\n    state.weights.popular = weight;\n    return this;\n}\n\nexport function setSelectionWeightStriking(weight) {\n    state.weights.striking = weight;\n    return this;\n}\n\nexport function setSelectionWeightMedium(weight) {\n    state.weights.medium = weight;\n    return this;\n}\n\nexport function setSelectionWeightSmall(weight) {\n    state.weights.small = weight;\n    return this;\n}\n\nexport function setDrawBeginCallback(drawBeginCallback) {\n    state.drawBeginCallback =\n        (ctx) => drawBeginCallback(ctx, state.drawState.constellation);\n    return this;\n}\n\nexport function setDrawFrameCompleteCallback(drawFrameCompleteCallback) {\n    state.drawFrameCompleteCallback =\n        (ctx, redrew) =>\n            drawFrameCompleteCallback(\n                ctx, redrew, state.drawState.constellation);\n    return this;\n}\n\nexport function setDrawCompleteCallback(drawCompleteCallback) {\n    state.drawCompleteCallback =\n        (ctx) => drawCompleteCallback(ctx, state.drawState.constellation);\n    return this;\n}\n\n\n\n/**\n * Functions for controlling ConstellationSketcher\n*/\n\n\n\nexport function sketch() {\n    state.slideshow = false;\n    setup();\n    if (state.mode !== \"waiting\" && state.mode !== \"uninitialized\")\n        return;\n    startSketch();\n}\n\nexport function slideshow() {\n    state.slideshow = true;\n    setup();\n    if (state.mode !== \"waiting\" && state.mode !== \"uninitialized\")\n        return;\n    startSlideshow();\n}\n\nexport function stop() {\n    state.mode = \"waiting\";\n    if (state.frameRequest !== null) {\n        window.cancelAnimationFrame(state.frameRequest);\n        state.frameRequest = null;\n        state.fadeState = null;\n        state.oldDrawState = null;\n    }\n    if (state.slideshowTimeout !== null) {\n        clearTimeout(state.slideshowTimeout);\n        state.slideshowTimeout = null;\n    }\n}\n\nexport function reset() {\n    stop();\n    Object.assign(state, defaults);\n    state.weights = JSON.parse(JSON.stringify(defaults.weights));\n}\n\n\n\n/**\n * Internal functions\n*/\n\n\n\nfunction setup() {\n    if (state.slideshowTimeout !== null) {\n        clearTimeout(state.slideshowTimeout);\n        state.slideshowTimeout = null;\n    }\n    \n    if (state.mode === \"uninitialized\") {\n        let canvas = document.getElementById(\"constellation-sketcher\");\n        state.ctx = canvas.getContext('2d');\n        state.width = canvas.width;\n        state.height = canvas.height;\n        state.canvasScale = Math.max(state.width, state.height);\n        state.padding = .1 * state.width;\n        state.mode = \"waiting\";\n    }\n}\n\nfunction clearCanvas() {\n    state.ctx.fillStyle = 'rgb(0, 0, 0)';\n    state.ctx.fillRect(0, 0, state.width, state.height);\n}\n\nfunction startSlideshow() {\n    state.slideshowTimeout = null;\n    startSketch();\n}\n\nfunction startSketch() {\n    // Track recent constellations\n    state.recentConstellations.push(state.nextConstellation);\n    if (state.recentConstellations.length > 6)\n        state.recentConstellations.shift();\n    \n    state.oldDrawState = state.drawState;\n    \n    state.drawState = {\n        constellation: state.nextConstellation,\n        linesToDraw: [],\n        linesDrawing: [],\n        linesFinished: [],\n        stars: [],\n        twinkleDeltaMags: [],\n        fraction: 0,\n        aniStart: 0,\n        aniDuration: 0,\n        twinkleTimestamp: performance.now(),\n    };\n    \n    if (state.slideshow)\n        chooseRandomConstellation();\n    else\n        state.nextConstellation = null;\n    \n    if (state.drawBeginCallback instanceof Function)\n        state.drawBeginCallback(state.ctx);\n    \n    const cdat = constellationData[state.drawState.constellation];\n    // Functions which properly scale positions and magnitudes\n    const sx = (x) => (x/1000 * (state.canvasScale - 2 * state.padding)\n                       + state.padding\n                       + (state.width - state.canvasScale)/2);\n    const sy = (y) => (y/1000 * (state.canvasScale - 2 * state.padding)\n                       + state.padding\n                       + (state.height - state.canvasScale)/2);\n    const sv = (v) => v/10\n    \n    for (let i=0; i<cdat.stars.x.length; i++) {\n        const data = [sx(cdat.stars.x[i]),\n                      sy(cdat.stars.y[i]),\n                      sv(cdat.stars.Vmag[i])]\n        state.drawState.stars.push(data);\n        state.drawState.twinkleDeltaMags.push(0);\n    }\n    \n    const lines = [];\n    if (state.drawLines) {\n        for (let i = 0; i < cdat.lines.start.length; i++) {\n            lines.push({\n                x1: sx(cdat.stars.x[cdat.lines.start[i]]),\n                y1: sy(cdat.stars.y[cdat.lines.start[i]]),\n                x2: sx(cdat.stars.x[cdat.lines.stop[i]]),\n                y2: sy(cdat.stars.y[cdat.lines.stop[i]]),\n            });\n        }\n    }\n    \n    if (state.animated && state.drawLines) {\n        const startLine = randomChoice(lines);\n        const [startLines, linesToDraw] = extractLinesAtPoint(\n            lines, startLine.x1, startLine.y1);\n        state.drawState.linesToDraw = linesToDraw;\n        state.drawState.linesDrawing = startLines;\n    } else\n        state.drawState.linesFinished = lines;\n    \n    if ((state.oldDrawState === null && state.fadeIn)\n            || (state.oldDrawState !== null && state.crossFade))\n        fadeIn();\n    else {\n        state.mode = \"waiting\";\n        if (state.animated && state.drawLines)\n            startAnimatingALine();\n        else {\n            redrawField();\n            onSketchEnd();\n        }\n    }\n}\n\n/**\n * Draws one frame in a fade-in animation. Requests that it be called\n * again if appropriate. Includes handling for setting up the fade\n * on the first frame and for moving along after the last frame.\n * \n * Handles both an initial fade-in from a transparent canvas and\n * cross-fades from one constellation to another.\n */\nfunction fadeIn(timestamp) {\n    let fadeIsStarting = false;\n    if (state.fadeState === null) {\n        fadeIsStarting = true;\n        // This is the first time through this function and the\n        // beginning of the fade.\n        state.mode = \"fading\";\n        timestamp = performance.now();\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = state.width;\n        canvas.height = state.height;\n        state.fadeState = {\n            aniStart: timestamp,\n            accumulatedOpacity: 0,\n            buffer: canvas,\n            bufferCtx: canvas.getContext(\"2d\"),\n            mainCtx: state.ctx,\n            mainDrawState: state.drawState,\n        };\n    } else if (state.mode !== \"fading\")\n        // The fade has been interrupted\n        return;\n    \n    // We only need to redraw everything from scratch when the stars twinkle,\n    // which isn't every frame. So we draw the old constellation on the main\n    // canvas and the new constellation on a buffer canvas which is drawn onto\n    // the main canvas with transparency, and on non-twinkle frames we just\n    // redraw that buffer to achieve the required opacity level.\n    if (twinkleIsTimedOut() || fadeIsStarting) {\n        state.fadeState.accumulatedOpacity = 0;\n        if (state.oldDrawState === null)\n            // We're fading in from transparent\n            state.ctx.clearRect(0, 0, state.width, state.height);\n        else {\n            // We're cross-fading from a previous constellation.\n            // We redraw that constellation here\n            state.drawState = state.oldDrawState;\n            drawLineFrame(timestamp);\n            state.drawState = state.fadeState.mainDrawState;\n        }\n        // Update the new star field in the buffer\n        state.ctx = state.fadeState.bufferCtx;\n        drawLineFrame(state.drawState.aniStart);\n        state.ctx = state.fadeState.mainCtx;\n    }\n    \n    // We'll draw the incoming constellation with a time-varying\n    // global alpha value.\n    const aniDuration = state.oldDrawState === null\n                         ? state.fadeInTime\n                         : state.crossFadeTime;\n    let targetOpac = (timestamp - state.fadeState.aniStart) / aniDuration;\n    if (targetOpac > 1) targetOpac = 1;\n    if (targetOpac < 0) targetOpac = 0;\n    // Calculate what opacity we have to draw with to reach our target\n    // opacity, given what's already been drawn.\n    const opac = (targetOpac - state.fadeState.accumulatedOpacity)\n                  / (1 - state.fadeState.accumulatedOpacity);\n    \n    state.ctx.globalAlpha = opac;\n    state.ctx.drawImage(state.fadeState.buffer, 0, 0);\n    state.ctx.globalAlpha = 1;\n    state.fadeState.accumulatedOpacity = targetOpac;\n    \n    if (targetOpac >= 1) {\n        state.fadeState = null;\n        state.oldDrawState = null;\n        state.mode = \"waiting\";\n        state.frameRequest = window.requestAnimationFrame(\n            state.animated && state.drawLines\n                ? startAnimatingALine\n                : onSketchEnd);\n    } else {\n        state.frameRequest = window.requestAnimationFrame(fadeIn);\n    }\n}\n\n/**\n * Handles one-off activities after a sketch is completed.\n */\nfunction onSketchEnd() {\n    state.mode = \"waiting\";\n    if (state.drawCompleteCallback instanceof Function)\n        state.drawCompleteCallback(state.ctx);\n    sketchIsEnded();\n}\n\n/**\n * Provides an \"idle loop\" after sketching has ended. Schedules calls\n * to itself to ensure stars continue to twinkle. Queues up another\n * constellation after the appropriate delay if in slideshow mode.\n */\nfunction sketchIsEnded() {\n    if (state.mode === \"waiting\" && state.twinkle) {\n        if (twinkleIsTimedOut()) {\n            redrawField();\n            if (state.drawFrameCompleteCallback instanceof Function)\n                state.drawFrameCompleteCallback(state.ctx, true);\n        }\n        state.frameRequest = window.requestAnimationFrame(sketchIsEnded)\n    }\n    if (state.slideshow\n        && state.mode === \"waiting\"\n        && state.slideshowTimeout === null) {\n        state.slideshowTimeout = setTimeout(() => {\n            startSlideshow();\n        }, state.slideshowDwellTime);\n    }\n}\n\n/**\n * Prepares to draw one line or set of lines as part of an animation.\n * \n * The main role of this function is to determine the speed at which the lines\n * are drawn, which is scaled by the length of the longest line so that lines\n * always grow at a ~constant rate. state.drawState is configured according\n * to the speed that is selected.\n */\nfunction startAnimatingALine() {\n    const lengths = state.drawState.linesDrawing.map((line) => (\n        Math.sqrt(Math.pow((line.x2-line.x1)/state.canvasScale, 2)\n            + Math.pow((line.y2-line.y1)/state.canvasScale, 2))\n    ));\n    \n    state.drawState.fraction = 0;\n    state.drawState.aniStart = performance.now();\n    state.drawState.aniDuration = Math.max(...lengths) * 4000/state.speedScale;\n    \n    // Don't schedule a frame draw if other things are already going on.\n    if (state.mode === \"waiting\") {\n        state.mode = \"drawing_lines\";\n        state.frameRequest = window.requestAnimationFrame(drawLineFrame);\n    }\n}\n\n/**\n * Called through window.requestAnimationFrame, completes one frame of\n * animation when drawing lines. Will enqueue another call to this function\n * for the next frame or advance the sketching state, as appropriate.\n */\nfunction drawLineFrame(timestamp) {\n    if (state.mode !== \"drawing_lines\" && state.mode !== \"fading\")\n        return;\n    \n    let oldFraction = state.drawState.fraction;\n    let newFraction = ((timestamp - state.drawState.aniStart)\n                       / state.drawState.aniDuration);\n    if (newFraction > 1) newFraction = 1;\n    if (newFraction < oldFraction) newFraction = oldFraction;\n    state.drawState.fraction = newFraction;\n    \n    let redrew = false;\n    if ((state.twinkle && twinkleIsTimedOut()) || state.mode === \"fading\") {\n        redrawField();\n        oldFraction = 0;\n        redrew = true;\n    }\n    \n    state.drawState.linesDrawing.forEach((line) => {\n        const dx = line.x2 - line.x1;\n        const dy = line.y2 - line.y1;\n        const x1 = line.x1 + dx * oldFraction;\n        const x2 = x1 + dx * (newFraction - oldFraction);\n        const y1 = line.y1 + dy * oldFraction;\n        const y2 = y1 + dy * (newFraction - oldFraction);\n        drawLine(x1, x2, y1, y2)\n    });\n    \n    if (state.drawFrameCompleteCallback instanceof Function)\n        state.drawFrameCompleteCallback(state.ctx, redrew);\n    \n    if (newFraction >= 1 && state.mode !== \"fading\") {\n        let lines = state.drawState.linesToDraw;\n        let linesDrawing = [];\n        state.drawState.linesFinished.push(...state.drawState.linesDrawing);\n        state.drawState.linesDrawing.forEach((line) => {\n            let newLinesDrawing;\n            [newLinesDrawing, lines] = extractLinesAtPoint(\n                lines, line.x2, line.y2);\n            linesDrawing.push(...newLinesDrawing);\n        });\n        if (linesDrawing.length === 0 && lines.length > 0) {\n            // Handle non-connected constellations (e.g. Crux)\n            const startLine = randomChoice(lines);\n            [linesDrawing, lines] = extractLinesAtPoint(lines,\n                startLine.x1, startLine.y1);\n        }\n        state.drawState.linesToDraw = lines;\n        state.drawState.linesDrawing = linesDrawing;\n        state.mode = \"waiting\";\n        if (state.drawState.linesDrawing.length > 0)\n            startAnimatingALine();\n        else\n            onSketchEnd();\n    } else\n        if (state.mode === \"drawing_lines\")\n            state.frameRequest = window.requestAnimationFrame(drawLineFrame)\n}\n\n/**\n * Returns True if stars should be redrawn this frame so they twinkle.\n */\nfunction twinkleIsTimedOut() {\n    const dt = performance.now() - state.drawState.twinkleTimestamp;\n    return state.twinkle && (dt > state.twinkleTimescale);\n}\n\n/**\n * Draws the field from scratch, including the black BG, all the stars,\n * and every constellation line that has already been completed. Star\n * twinkle is updated if appropriate.\n */\nfunction redrawField() {\n    clearCanvas();\n    if (twinkleIsTimedOut()) {\n        state.drawState.twinkleDeltaMags = state.drawState.stars.map((data) =>{\n            const mag = data[2];\n            return (10 - mag)\n                * (Math.random() * 0.15 - 0.075)\n                * state.twinkleAmplitude;\n        });\n        state.drawState.twinkleTimestamp = performance.now();\n    }\n    state.drawState.stars.forEach((data, idx) => {\n        let [x, y, mag] = data;\n        mag += state.drawState.twinkleDeltaMags[idx];\n        drawStar(x, y, mag);\n    });\n    state.drawState.linesFinished.forEach((line) => {\n        drawLine(line.x1, line.x2, line.y1, line.y2);\n    });\n}\n\nfunction drawStar(x, y, Vmag) {\n    const r = (7 - Vmag) * state.canvasScale / 2000 * state.sizeScale + 0.5;\n    let opac = 1 - .15 * (Vmag-1);\n    if (opac > 1) opac = 1;\n    if (opac < 0) opac = 0;\n    state.ctx.beginPath();\n    state.ctx.fillStyle = `rgba(255,255,255,${opac})`;\n    state.ctx.arc(x, y, r, 0, Math.PI * 2);\n    state.ctx.fill();\n}\n\nfunction drawLine(x1, x2, y1, y2) {\n    state.ctx.beginPath();\n    state.ctx.strokeStyle = 'rgba(255,239,187,0.4)';\n    state.ctx.lineWidth = Math.max(2, 2 * state.canvasScale / 500);\n    state.ctx.moveTo(x1, y1);\n    state.ctx.lineTo(x2, y2);\n    state.ctx.stroke()\n}\n\nexport const constellationNames = Object.keys(constellationData);\nexport {constellationCategories as categories};"],"sourceRoot":""}